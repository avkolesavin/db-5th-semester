Внутри функций триггеров в PostgreSQL доступны следующие специальные переменные:

* `NEW`: Тип данных `RECORD`. Переменная содержит новую строку базы данных для команд `INSERT` / `UPDATE` в триггерах уровня строки. В триггерах уровня оператора и для команды `DELETE` эта переменная имеет значение `null`.
* `OLD`: Тип данных RECORD. Переменная `содержит` старую строку базы данных для команд UPDATE / `DELETE` в триггерах уровня строки. В триггерах уровня оператора и для команды `INSERT` эта переменная имеет значение `null`.
* `TG_NAME`: Тип данных name. Переменная содержит имя сработавшего триггера.
TG_WHEN: Тип данных text. Строка, содержащая BEFORE, `AFTER` или `INSTEAD OF`, в зависимости от определения триггера.
* `TG_LEVEL`: Тип данных `text`. Строка, содержащая ROW или STATEMENT, в зависимости от определения триггера.
* `TG_OP`: Тип данных `text`. Строка, содержащая `INSERT`, `UPDATE`, `DELETE` или `TRUNCATE`, в зависимости от того, для какой операции сработал триггер.
* `TG_RELID`: Тип данных `oid`. `OID` таблицы, для которой сработал триггер.
* `TG_RELNAME`: Тип данных name. Имя таблицы, для которой сработал триггер. Эта переменная устарела и может стать недоступной в будущих релизах. Вместо неё нужно использовать `TG_TABLE_NAME`.
* `TG_TABLE_NAME`: Тип данных name. Имя таблицы, для которой сработал триггер.
* `TG_TABLE_SCHEMA`: Тип данных name. Имя схемы, содержащей таблицу, для которой сработал триггер.
* `TG_NARGS`: Тип данных `integer`. Число аргументов в команде `CREATE TRIGGER`, которые передаются в триггерную функцию.
* `TG_ARGV []`: Тип данных массив `text`. Аргументы от оператора `CREATE TRIGGER`. Индекс массива начинается с 0. Для недопустимых значений индекса `( < 0 или >= tg_nargs)` возвращается `NULL`.

Вывод сообщения: `RAISE NOTICE`. Пример: `RAISE NOTICE 'Триггер % сработал на таблице %', TG_NAME, TG_TABLE_NAME;`

Вывод ошибки и прекращение выполения: `RAISE EXCEPTION`.

`PERFORM` используется для вызова процедуры или функции, когда вам не нужен возвращаемый результат.

`CALL` может быть использован только для процедур, которые не возвращают результат. Если ваша процедура возвращает результат, вы должны использовать `SELECT`.